package netproj2;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Point;
import java.util.HashMap;
import javax.swing.ImageIcon;
import javax.swing.JOptionPane;

/**
 *
 * @author Ahmed El-Torky
 */
public class Prog extends javax.swing.JFrame {

    private Graphics2D gfx;
    private static final int NODE_WIDTH = 64, NODE_HEIGHT = 64, START_LINE = 0, END_LINE = 1;
    private HashMap<Integer, Point> nodesLocation;
    private HashMap<Integer, Integer[]> lines;
    private HashMap<Integer, Point> valuesLocation;
    private HashMap<Integer, String> values;
    private int nodeID = 0, lineID = 0;
    private int startX = 0, startY = 0, endX = 0, endY = 0;
    private boolean startLineFlag = false, lineExist = false;
    private Point startLine, endLine;
    private int startNodeID = -1, endNodeID = -1;
    private MinimumSpanningTree mst;
    private final Image backGround;

    /**
     * Creates new form Prog
     */
    public Prog() {
        initComponents();
        setTitle("Network Routing Project Demo");
        setResizable(false);
        gfx = (Graphics2D) jPanel1.getGraphics();
        nodesLocation = new HashMap<>();
        lines = new HashMap<>();
        valuesLocation = new HashMap<>();
        values = new HashMap<>();
        backGround = new ImageIcon("background.png").getImage();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        solve = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jPanel1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jPanel1MouseClicked(evt);
            }
            public void mousePressed(java.awt.event.MouseEvent evt) {
                jPanel1MousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                jPanel1MouseReleased(evt);
            }
        });

        solve.setText("Solve");
        solve.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                solveActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap(722, Short.MAX_VALUE)
                .addComponent(solve)
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap(457, Short.MAX_VALUE)
                .addComponent(solve)
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jPanel1MousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jPanel1MousePressed
        // TODO add your handling code here:
        if (evt.isAltDown()) {
            if (this.checkNodeForLine(evt.getX(), evt.getY(), START_LINE)) {
                startLineFlag = true;
            }
        } else {
            if (this.checkIfValue(evt.getX(), evt.getY())) {
                Point p = new Point(evt.getX(), evt.getY());
                int id = -1;
                for (int i = 0; i < valuesLocation.size(); i++) {
                    if (p.x >= valuesLocation.get(i).x - 10 && p.x <= valuesLocation.get(i).x + 10) {
                        if (p.y <= valuesLocation.get(i).y + 10 && p.y >= valuesLocation.get(i).y - 10) {
                            id = i;
                            break;
                        }
                    }
                }
                String newValue = JOptionPane.showInputDialog(null, "please enter the new value:", "Changing Line Value", JOptionPane.QUESTION_MESSAGE);
                if (this.checkValidityOfValue(newValue)) {
                    values.replace(id, newValue);
                    this.paint(gfx);
                } else {
                    JOptionPane.showMessageDialog(rootPane, "You Entered Invalid Value !!!", "Invalid Value", JOptionPane.ERROR_MESSAGE);
                }
            }
        }
    }//GEN-LAST:event_jPanel1MousePressed

    private void jPanel1MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jPanel1MouseClicked
        // TODO add your handling code here:
        if (evt.isControlDown()) {
            if (this.checkNotNode(evt.getX(), evt.getY())) {
                nodesLocation.put(nodeID, new Point(evt.getX(), evt.getY()));
                nodeID++;
                this.drawAllNodes();
            }
        }
    }//GEN-LAST:event_jPanel1MouseClicked

    private void jPanel1MouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jPanel1MouseReleased
        // TODO add your handling code here:
        if (evt.isAltDown() && startLineFlag == true) {
            if (this.checkNodeForLine(evt.getX(), evt.getY(), END_LINE)) {
                if (startNodeID != endNodeID) {
                    Integer[] ns = {startNodeID, endNodeID};
                    // check if this line is exist
                    for (int i = 0; i < lines.size(); i++) {
                        Integer[] temp = (Integer[]) lines.values().toArray()[i];
                        if ((ns[0] == temp[0] && ns[1] == temp[1]) || (ns[0] == temp[1] && ns[1] == temp[0])) {
                            lineExist = true;
                            break;
                        }
                    }
                    if (!lineExist) {
                        lines.put(lineID, ns);
                        lineID++;
                        this.paint(gfx);
                    } else {
                        startNodeID = -1;
                        endNodeID = -1;
                        startLineFlag = false;
                        lineExist = false;
                    }
                } else {
                    startNodeID = -1;
                    endNodeID = -1;
                    startLineFlag = false;
                }
            } else {
                startNodeID = -1;
                endNodeID = -1;
                startLineFlag = false;
            }
        }
    }//GEN-LAST:event_jPanel1MouseReleased

    private void solveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_solveActionPerformed
        // TODO add your handling code here:
        this.collectData();
    }//GEN-LAST:event_solveActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Prog.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Prog.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Prog.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Prog.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Prog().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel jPanel1;
    private javax.swing.JButton solve;
    // End of variables declaration//GEN-END:variables

    public void drawAllNodes() {
        for (int i = 0; i < nodesLocation.size(); i++) {
            Point p = (Point) nodesLocation.values().toArray()[i];
            gfx.setColor(Color.orange);
            gfx.fillOval(p.x - (NODE_WIDTH / 2), p.y - (NODE_HEIGHT / 2), 50, 50);
            gfx.setFont(new Font("Arial", Font.BOLD, 14));
            gfx.setColor(Color.black);
            gfx.drawString("Node " + ((Integer) nodesLocation.keySet().toArray()[i] + 1), p.x - 20, p.y + 45);
        }
    }

    @Override
    public void paint(Graphics g) {
        gfx.drawImage(backGround, 0, 0, this);
        this.drawAllLines();
        this.drawAllNodes();
        this.drawAllValues();
        solve.updateUI();
    }

    public boolean checkNotNode(int x, int y) {
        for (int i = 0; i < nodesLocation.size(); i++) {
            Point checkPoint = (Point) nodesLocation.values().toArray()[i];
            if (x >= checkPoint.x - NODE_WIDTH && x <= checkPoint.x + NODE_WIDTH) {
                if (y <= checkPoint.y + NODE_HEIGHT && y >= checkPoint.y - NODE_HEIGHT) {
                    return false;
                }
            }
        }
        return true;
    }

    public boolean checkNodeForLine(int x, int y, int status) {
        for (int i = 0; i < nodesLocation.size(); i++) {
            Point checkPoint = (Point) nodesLocation.values().toArray()[i];
            if (x >= checkPoint.x - 20 && x <= checkPoint.x + 20) {
                if (y <= checkPoint.y + 20 && y >= checkPoint.y - 20) {
                    if (status == START_LINE) {
                        startNodeID = (Integer) nodesLocation.keySet().toArray()[i];
                    } else if (status == END_LINE) {
                        endNodeID = (Integer) nodesLocation.keySet().toArray()[i];
                    }
                    return true;
                }
            }
        }
        return false;
    }

    public boolean checkIfValue(int x, int y) {
        for (int i = 0; i < valuesLocation.size(); i++) {
            Point checkPoint = (Point) valuesLocation.values().toArray()[i];
            if (x >= checkPoint.x - 10 && x <= checkPoint.x + 10) {
                if (y <= checkPoint.y + 10 && y >= checkPoint.y - 10) {
                    return true;
                }
            }
        }
        return false;
    }

    public void drawAllLines() {
        Point startNode = null, endNode = null;
        for (int i = 0; i < lines.size(); i++) {
            Integer startEndLine[] = (Integer[]) lines.values().toArray()[i];
            // check for start node of line
            for (int j = 0; j < nodesLocation.size(); j++) {
                if (startEndLine[0] == (Integer) nodesLocation.keySet().toArray()[j]) {
                    startNode = (Point) nodesLocation.values().toArray()[j];
                }
            }
            // check for end node of line
            for (int j = 0; j < nodesLocation.size(); j++) {
                if (startEndLine[1] == (Integer) nodesLocation.keySet().toArray()[j]) {
                    endNode = (Point) nodesLocation.values().toArray()[j];
                }
            }
            // draw the line
            gfx.setStroke(new BasicStroke(3));
            gfx.setColor(Color.gray);
            gfx.drawLine(startNode.x, startNode.y, endNode.x, endNode.y);
        }
    }

    public void drawAllValues() {
        Integer[] psID;
        int lineID;
        Point sp = null, ep = null;
        for (int i = 0; i < lines.size(); i++) {
            lineID = (Integer) lines.keySet().toArray()[i];
            psID = (Integer[]) lines.values().toArray()[i];
            for (int j = 0; j < nodesLocation.size(); j++) {
                if (psID[0] == (Integer) nodesLocation.keySet().toArray()[j]) {
                    sp = (Point) nodesLocation.values().toArray()[j];
                }
            }
            for (int j = 0; j < nodesLocation.size(); j++) {
                if (psID[1] == (Integer) nodesLocation.keySet().toArray()[j]) {
                    ep = (Point) nodesLocation.values().toArray()[j];
                }
            }
            Point p = new Point((sp.x + ep.x) / 2, (sp.y + ep.y) / 2);
            valuesLocation.put(lineID, p);
            if (values.get(lineID) == null) {
                values.put(lineID, "**");
            }
            gfx.setColor(Color.BLACK);
            gfx.drawString((String) values.get(lineID), p.x, p.y);
        }
    }

    public boolean checkValidityOfValue(String value) {
        try {
            Integer.parseInt(value);
            return true;
        } catch (NumberFormatException ex) {
            return false;
        }
    }

    public void collectData() {
        int[][] linesValues = new int[lines.size()][3];
        for (int i = 0; i < lines.size(); i++) {
            Integer[] nodesId = (Integer[]) lines.values().toArray()[i];
            linesValues[i][0] = nodesId[0];
            linesValues[i][1] = nodesId[1];
            linesValues[i][2] = Integer.parseInt(values.get(lines.keySet().toArray()[i]));
        }
        for (int[] linesValue : linesValues) {
            System.out.print(linesValue[0] + "\t" + linesValue[1] + "\t" + linesValue[2]);
            System.out.println();
        }
        int length = nodesLocation.size();
        mst = new MinimumSpanningTree(length);
        int arr[][] = new int[length][length];
        for (int i = 0; i < linesValues.length; i++) {
            arr[linesValues[i][0]][linesValues[i][1]] = linesValues[i][2];
            arr[linesValues[i][1]][linesValues[i][0]] = linesValues[i][2];
        }
        for (int r = 0; r < length; r++) {
            for (int c = 0; c < length; c++) {
                if (arr[r][c] == 0) {
                    arr[r][c] = 99;
                }
            }
        }
        for (int i = 0; i < length; i++) {
            arr[i][i] = 0;
        }
        System.out.println();
        for (int r = 0; r < length; r++) {
            for (int c = 0; c < length; c++) {
                System.out.print(arr[r][c] + "\t");
            }
            System.out.println();
        }

        int[][] ms = mst.minimumSpanningTree(arr);
        System.out.println("\nminimum spanning tree:");
        for (int r = 0; r < ms.length; r++) {
            for (int c = 0; c < ms.length; c++) {
                System.out.print(ms[r][c] + "\t");
            }
            System.out.println();
        }
        lines = new HashMap<>();
        values = new HashMap<>();
        valuesLocation = new HashMap<>();
        int id = 0;
        for (int r = 0; r < ms.length; r++) {
            for (int c = 0; c < ms.length; c++) {
                if (ms[r][c] != 0 && ms[r][c] != 99) {
                    Integer ns[] = {r, c};
                    lines.put(id, ns);
                    values.put(id, Integer.toString(ms[r][c]));
                    Point sp = nodesLocation.get(r);
                    Point ep = nodesLocation.get(c);
                    Point p = new Point((sp.x + ep.x) / 2, (sp.y + ep.y) / 2);
                    valuesLocation.put(id, p);
                    id++;
                }
            }
        }
        this.paint(gfx);
    }
}
